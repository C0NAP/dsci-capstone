@page "/Graph"

@using Syncfusion.Blazor.Diagram
@using Syncfusion.Blazor.Buttons
@using Neo4j.Driver

@inject IDriver Neo4jDriver

<h3>Neo4j Graph Visualization with Syncfusion</h3>

<div style="display:flex; height:80vh;">
    <div style="flex:1; border:1px solid gray;">
        <SfDiagramComponent @ref="DiagramRef" 
                           Height="100%" 
                           Width="100%"
                           Nodes="@nodes" 
                           Connectors="@connectors"
                           Click="@OnClick"
                           ScrollChanged="@OnScrollChanged">
            
            @* Enable Interactive Pan and Zoom with Mouse Wheel *@
            <ScrollSettings CurrentZoom="1.0" 
                           MinZoom="0.2" 
                           MaxZoom="5.0"
                           HorizontalOffset="0" 
                           VerticalOffset="0"
                           EnableAutoScroll="true"
                           ScrollLimit="ScrollLimitMode.Infinity"
                           CurrentZoomChanged="@OnZoomChanged"
                           HorizontalOffsetChanged="@OnPanChanged"
                           VerticalOffsetChanged="@OnPanChanged">
            </ScrollSettings>
            
            @* Enable snap to grid for better node positioning *@
            <SnapSettings Constraints="SnapConstraints.ShowLines">
            </SnapSettings>
            
        </SfDiagramComponent>
    </div>
    
    <div style="width:300px; padding:10px; border-left:1px solid gray;">
        <h4>Zoom & Pan Controls</h4>
        <div style="margin-bottom:15px;">
            <SfButton Content="Zoom In" CssClass="e-primary e-small" OnClick="@ZoomIn" />
            <SfButton Content="Zoom Out" CssClass="e-primary e-small" OnClick="@ZoomOut" />
            <SfButton Content="Fit to Page" CssClass="e-success e-small" OnClick="@FitToPage" />
            <SfButton Content="Reset" CssClass="e-danger e-small" OnClick="@ResetView" />
        </div>
        
        <h4>Current Status</h4>
        <div style="margin-bottom:15px;">
            <p><strong>Zoom:</strong> @currentZoom.ToString("F2")x</p>
            <p><strong>Pan X:</strong> @horizontalOffset.ToString("F0")px</p>
            <p><strong>Pan Y:</strong> @verticalOffset.ToString("F0")px</p>
        </div>
        
        <h4>Selected Item</h4>
        <pre style="background:#f5f5f5; padding:10px; border-radius:4px;">@selectedInfo</pre>

        <h4>Debug Info</h4>
        <p><strong>Nodes:</strong> @nodes.Count</p>
        <p><strong>Connectors:</strong> @connectors.Count</p>

        <details>
            <summary>Node Details</summary>
            <div style="max-height:200px; overflow-y:auto;">
                @foreach (var node in nodes)
                {
                    <p style="font-size:12px; margin:2px 0;">
                        @node.ID - (@node.OffsetX.ToString("F0"), @node.OffsetY.ToString("F0"))
                    </p>
                }
            </div>
        </details>
    </div>
</div>

@code {
    private SfDiagramComponent? DiagramRef;
    private readonly DiagramObjectCollection<Node> nodes = [];
    private readonly DiagramObjectCollection<Connector> connectors = [];
    
    private string selectedInfo = "Click a node or connector to view details";
    private double currentZoom = 1.0;
    private double horizontalOffset = 0;
    private double verticalOffset = 0;

    private readonly Dictionary<string, (string label, List<string> properties)> nodeData = [];

    protected override async Task OnInitializedAsync()
    {
        await LoadGraphFromNeo4j();
    }

    private async Task LoadGraphFromNeo4j()
    {
        var session = Neo4jDriver.AsyncSession();
        var processedNodes = new HashSet<string>();
        var processedRelationships = new HashSet<string>();

        try
        {
            var result = await session.RunAsync(@"
                MATCH (n)-[r]->(m)
                RETURN n, r, m
                LIMIT 50
            ");

            await result.ForEachAsync(record =>
            {
                var n1Node = record["n"].As<INode>();
                var n2Node = record["m"].As<INode>();
                var rel = record["r"].As<IRelationship>();

                // Process source node
                if (!processedNodes.Contains(n1Node.ElementId))
                {
                    var node1 = CreateNodeFromNeo4j(n1Node);
                    nodes.Add(node1);
                    processedNodes.Add(n1Node.ElementId);
                }

                // Process target node
                if (!processedNodes.Contains(n2Node.ElementId))
                {
                    var node2 = CreateNodeFromNeo4j(n2Node);
                    nodes.Add(node2);
                    processedNodes.Add(n2Node.ElementId);
                }

                // Process relationship
                var relationshipKey = $"{n1Node.ElementId}-{rel.Type}-{n2Node.ElementId}";
                if (!processedRelationships.Contains(relationshipKey))
                {
                    var connector = CreateConnectorFromNeo4j(n1Node.ElementId, n2Node.ElementId, rel);
                    connectors.Add(connector);
                    processedRelationships.Add(relationshipKey);
                }
            });
        }
        finally
        {
            await session.CloseAsync();
        }
    }

    private Node CreateNodeFromNeo4j(INode neoNode)
    {
        var label = neoNode.Labels.FirstOrDefault() ?? "Node";
        var properties = neoNode.Properties.Select(kvp => $"{kvp.Key}: {kvp.Value}").ToList();
        
        // Store node data for selection display
        nodeData[neoNode.ElementId] = (label, properties);

        return new Node()
        {
            ID = neoNode.ElementId,
            OffsetX = GetRandomPosition(100, 800),
            OffsetY = GetRandomPosition(100, 600),
            Width = 120,
            Height = 60,
            Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Ellipse },
            Style = new ShapeStyle() 
            { 
                Fill = GetNodeColor(label),
                StrokeColor = "#333333",
                StrokeWidth = 2
            },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>()
            {
                new ShapeAnnotation 
                { 
                    Content = label,
                    Style = new TextStyle() 
                    { 
                        Color = "white", 
                        Bold = true,
                        FontSize = 12
                    }
                }
            }
        };
    }

    private Connector CreateConnectorFromNeo4j(string sourceId, string targetId, IRelationship relationship)
    {
        return new Connector()
        {
            ID = $"conn_{sourceId}_{targetId}_{relationship.Type}",
            SourceID = sourceId,
            TargetID = targetId,
            Type = ConnectorSegmentType.Straight,
            Style = new ShapeStyle()
            {
                StrokeColor = "#6495ED",
                StrokeWidth = 2
            },
            TargetDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.Arrow,
                Style = new ShapeStyle() { Fill = "#6495ED", StrokeColor = "#6495ED" }
            },
            Annotations = new DiagramObjectCollection<PathAnnotation>()
            {
                new PathAnnotation() 
                { 
                    Content = relationship.Type,
                    Style = new TextStyle() 
                    { 
                        Color = "#333333",
                        FontSize = 10,
                        Bold = true
                    }
                }
            }
        };
    }

    private string GetNodeColor(string label)
    {
        // Generate colors based on node labels
        var colors = new[] { "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8" };
        var hash = label.GetHashCode();
        return colors[Math.Abs(hash) % colors.Length];
    }

    private double GetRandomPosition(int min, int max)
    {
        var random = new Random();
        return random.Next(min, max);
    }

    #region Event Handlers

    private void OnClick(ClickEventArgs args)
    {
        if (args.Element != null)
        {
            if (args.Element is Node selectedNode)
            {
                if (selectedNode.ID != null && nodeData.TryGetValue(selectedNode.ID, out var data))
                {
                    selectedInfo = $"Node: {data.label}\nID: {selectedNode.ID}\nProperties:\n{string.Join("\n", data.properties)}";
                }
                else
                {
                    selectedInfo = $"Node: {selectedNode.ID}";
                }
            }
            else if (args.Element is Connector selectedConnector)
            {
                selectedInfo = $"Connector: {selectedConnector.ID}\nFrom: {selectedConnector.SourceID}\nTo: {selectedConnector.TargetID}";
            }
        }
        else
        {
            selectedInfo = "Click a node or connector to view details";
        }
        
        StateHasChanged();
    }

    private void OnScrollChanged(ScrollChangedEventArgs args) {
        // Update current values when user pans/zooms
        if (DiagramRef?.ScrollSettings == null) return;
        currentZoom = DiagramRef.ScrollSettings.CurrentZoom;
        horizontalOffset = DiagramRef.ScrollSettings.HorizontalOffset;
        verticalOffset = DiagramRef.ScrollSettings.VerticalOffset;
        StateHasChanged();
    }

    private void OnZoomChanged() {
        if (DiagramRef?.ScrollSettings == null) return;
        currentZoom = DiagramRef.ScrollSettings.CurrentZoom;
        StateHasChanged();
    }

    private void OnPanChanged() {
        if (DiagramRef?.ScrollSettings == null) return;
        horizontalOffset = DiagramRef.ScrollSettings.HorizontalOffset;
        verticalOffset = DiagramRef.ScrollSettings.VerticalOffset;
        StateHasChanged();
    }

    #endregion

    #region Zoom and Pan Controls

    private async Task ZoomIn()
    {
        if (DiagramRef?.ScrollSettings != null)
        {
            var newZoom = Math.Min(currentZoom + 0.25, 5.0);
            DiagramRef.ScrollSettings.CurrentZoom = newZoom;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ZoomOut()
    {
        if (DiagramRef?.ScrollSettings != null)
        {
            var newZoom = Math.Max(currentZoom - 0.25, 0.2);
            DiagramRef.ScrollSettings.CurrentZoom = newZoom;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task FitToPage()
    {
        if (DiagramRef?.ScrollSettings != null && nodes.Count > 0)
        {
            // Calculate bounds of all nodes
            var minX = nodes.Min(n => n.OffsetX - n.Width / 2);
            var maxX = nodes.Max(n => n.OffsetX + n.Width / 2);
            var minY = nodes.Min(n => n.OffsetY - n.Height / 2);
            var maxY = nodes.Max(n => n.OffsetY + n.Height / 2);

            var contentWidth = maxX - minX;
            var contentHeight = maxY - minY;

            // Estimate viewport size (you might need to adjust these values)
            var viewportWidth = 800.0;
            var viewportHeight = 600.0;

            var zoomX = viewportWidth / contentWidth;
            var zoomY = viewportHeight / contentHeight;
            var zoom = Math.Min((double)zoomX!, (double)zoomY!) * 0.9; // 90% of fit for padding

            // Apply zoom and center
            var newZoom = Math.Max(0.2, Math.Min(zoom, 5.0));
            DiagramRef.ScrollSettings.CurrentZoom = newZoom;
            DiagramRef.ScrollSettings.HorizontalOffset = (viewportWidth - (double)contentWidth! * newZoom) / 2 - (double)minX! * newZoom;
            DiagramRef.ScrollSettings.VerticalOffset = (viewportHeight - (double)contentHeight! * newZoom) / 2 - (double)minY! * newZoom;
            
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ResetView()
    {
        if (DiagramRef?.ScrollSettings != null)
        {
            DiagramRef.ScrollSettings.CurrentZoom = 1.0;
            DiagramRef.ScrollSettings.HorizontalOffset = 0;
            DiagramRef.ScrollSettings.VerticalOffset = 0;
            await InvokeAsync(StateHasChanged);
        }
    }

    #endregion
}