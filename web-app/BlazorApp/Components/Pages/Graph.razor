@page "/Graph"
@rendermode InteractiveServer

@using Syncfusion.Blazor.Diagram
@using Syncfusion.Blazor.Buttons
@using Neo4j.Driver

@inject IDriver Neo4jDriver
@inject ILogger<Graph> Logger

<h3>Neo4j Graph Visualization with Syncfusion</h3>

<div style="display:flex; height:80vh;">
    <div style="flex:1; border:1px solid gray;">
        <SfDiagramComponent @ref="DiagramRef" 
                           Height="100%" 
                           Width="100%"
                           Nodes="@nodes" 
                           Connectors="@connectors"
                           Click="@OnClick"
                           ScrollChanged="@OnScrollChanged"
                           InteractionController="@DiagramInteractions.ZoomPan"
                           Created="@OnDiagramCreated">
            
            @* Enable Interactive Pan and Zoom with Mouse Wheel *@
            <ScrollSettings CurrentZoom="1.0" 
                           MinZoom="0.2" 
                           MaxZoom="5.0"
                           HorizontalOffset="0" 
                           VerticalOffset="0"
                           EnableAutoScroll="true"
                           ScrollLimit="ScrollLimitMode.Infinity">
            </ScrollSettings>
            
            @* Enable snap to grid for better node positioning *@
            <SnapSettings Constraints="SnapConstraints.ShowLines">
            </SnapSettings>
            
        </SfDiagramComponent>
    </div>
    
    <div style="width:300px; padding:10px; border-left:1px solid gray;">
        <h4>Zoom & Pan Controls</h4>
        <div style="margin-bottom:15px;">
            <SfButton Content="Zoom In" CssClass="e-primary e-small" OnClick="@ZoomIn" />
            <SfButton Content="Zoom Out" CssClass="e-primary e-small" OnClick="@ZoomOut" />
            <SfButton Content="Fit to Page" CssClass="e-success e-small" OnClick="@FitToPage" />
            <SfButton Content="Reset" CssClass="e-danger e-small" OnClick="@ResetView" />
        </div>
        
        <h4>Current Status</h4>
        <div style="margin-bottom:15px;">
            <p><strong>Zoom:</strong> @currentZoom.ToString("F2")x</p>
            <p><strong>Pan X:</strong> @horizontalOffset.ToString("F0")px</p>
            <p><strong>Pan Y:</strong> @verticalOffset.ToString("F0")px</p>
        </div>
        
        <h4>Selected Item</h4>
        <pre style="background:#f5f5f5; padding:10px; border-radius:4px;">@selectedInfo</pre>

        <h4>Debug Info</h4>
        <p><strong>Nodes:</strong> @nodes.Count</p>
        <p><strong>Connectors:</strong> @connectors.Count</p>

        <details>
            <summary>Node Details</summary>
            <div style="max-height:200px; overflow-y:auto;">
                @foreach (var node in nodes)
                {
                    <p style="font-size:12px; margin:2px 0;">
                        @node.ID - (@node.OffsetX.ToString("F0"), @node.OffsetY.ToString("F0"))
                    </p>
                }
            </div>
        </details>
    </div>
</div>

@code {
    private SfDiagramComponent? DiagramRef;
    private readonly DiagramObjectCollection<Node> nodes = [];
    private readonly DiagramObjectCollection<Connector> connectors = [];
    
    private string selectedInfo = "Click a node or connector to view details";
    private double currentZoom = 1.0;
    private double horizontalOffset = 0;
    private double verticalOffset = 0;

    private readonly Dictionary<string, (string label, List<string> properties)> nodeData = [];

    
    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("Loading initial graph...");
        await LoadGraphFromNeo4j();

        // Force UI update so Diagram can render nodes
        StateHasChanged();
    }

    private async Task OnDiagramCreated()
    {
        Logger.LogInformation("Diagram created; safe to add nodes/connectors and call FitToPage.");

        if (nodes.Count > 0)
        {
            DiagramRef?.FitToPage();
            DebugDiagramTransformed(sampleNodes: 10);
            await InvokeAsync(StateHasChanged);
        }
        else
        {
            Logger.LogWarning("No nodes loaded to display in Diagram.");
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogInformation(
                "First render complete. Nodes: {NodeCount}, Connectors: {ConnectorCount}", 
                nodes.Count, connectors.Count);

            if (nodes.Count > 0)
            {
                Logger.LogInformation("Nodes loaded; waiting for Diagram Created event to apply FitToPage.");
            }
            else
            {
                Logger.LogWarning("No nodes loaded from Neo4j!");
            }
        }

        return Task.CompletedTask;
    }




    private async Task LoadGraphFromNeo4j()
    {
        var session = Neo4jDriver.AsyncSession();
        var processedNodes = new HashSet<string>();
        var processedRelationships = new HashSet<string>();

        try
        {
            Logger.LogInformation("Running Cypher query...");
            var result = await session.RunAsync(@"
                MATCH (n)-[r]->(m)
                RETURN n, r, m
                LIMIT 50
            ");
            var records = await result.ToListAsync();
            Logger.LogInformation("Fetched {Count} results.", records.Count);
            
            foreach (var record in records)
            {
                var n1Node = record["n"].As<INode>();
                var n2Node = record["m"].As<INode>();
                var rel = record["r"].As<IRelationship>();

                // Process source node
                if (!processedNodes.Contains(n1Node.ElementId))
                {
                    var node1 = CreateNodeFromNeo4j(n1Node);
                    nodes.Add(node1);
                    processedNodes.Add(n1Node.ElementId);
                }

                // Process target node
                if (!processedNodes.Contains(n2Node.ElementId))
                {
                    var node2 = CreateNodeFromNeo4j(n2Node);
                    nodes.Add(node2);
                    processedNodes.Add(n2Node.ElementId);
                }

                // Process relationship
                var relationshipKey = $"{n1Node.ElementId}-{rel.Type}-{n2Node.ElementId}";
                if (!processedRelationships.Contains(relationshipKey))
                {
                    var connector = CreateConnectorFromNeo4j(n1Node.ElementId, n2Node.ElementId, rel);
                    connectors.Add(connector);
                    processedRelationships.Add(relationshipKey);
                }
            }
            
            Logger.LogInformation("Created {NodeCount} nodes and {ConnectorCount} relations.", nodes.Count, connectors.Count);
        }
        finally
        {
            await session.CloseAsync();
        }
    }

    private Node CreateNodeFromNeo4j(INode neoNode)
    {
        var label = neoNode.Labels.FirstOrDefault() ?? "Node";
        var properties = neoNode.Properties.Select(kvp => $"{kvp.Key}: {kvp.Value}").ToList();
        
        // Store node data for selection display
        nodeData[neoNode.ElementId] = (label, properties);

        return new Node()
        {
            ID = neoNode.ElementId,
            OffsetX = GetRandomPosition(100, 800),
            OffsetY = GetRandomPosition(100, 600),
            Width = 120,
            Height = 60,
            Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Ellipse },
            Style = new ShapeStyle() 
            { 
                Fill = GetNodeColor(label),
                StrokeColor = "#333333",
                StrokeWidth = 2
            },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>()
            {
                new ShapeAnnotation 
                { 
                    Content = label,
                    Style = new TextStyle() 
                    { 
                        Color = "white", 
                        Bold = true,
                        FontSize = 12
                    }
                }
            }
        };
    }

    private Connector CreateConnectorFromNeo4j(string sourceId, string targetId, IRelationship relationship)
    {
        return new Connector()
        {
            ID = $"conn_{sourceId}_{targetId}_{relationship.Type}",
            SourceID = sourceId,
            TargetID = targetId,
            Type = ConnectorSegmentType.Straight,
            Style = new ShapeStyle()
            {
                StrokeColor = "#6495ED",
                StrokeWidth = 2
            },
            TargetDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.Arrow,
                Style = new ShapeStyle() { Fill = "#6495ED", StrokeColor = "#6495ED" }
            },
            Annotations = new DiagramObjectCollection<PathAnnotation>()
            {
                new PathAnnotation() 
                { 
                    Content = relationship.Type,
                    Style = new TextStyle() 
                    { 
                        Color = "#333333",
                        FontSize = 10,
                        Bold = true
                    }
                }
            }
        };
    }

    private string GetNodeColor(string label)
    {
        // Generate colors based on node labels
        var colors = new[] { "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8" };
        var hash = label.GetHashCode();
        return colors[Math.Abs(hash) % colors.Length];
    }

    private static readonly Random _random = new();
    
    private double GetRandomPosition(int min, int max)
    {
        return _random.Next(min, max);
    }

    #region Event Handlers

    private void OnClick(ClickEventArgs args)
    {
        if (args.Element != null)
        {
            if (args.Element is Node selectedNode)
            {
                if (selectedNode.ID != null && nodeData.TryGetValue(selectedNode.ID, out var data))
                {
                    selectedInfo = $"Node: {data.label}\nID: {selectedNode.ID}\nProperties:\n{string.Join("\n", data.properties)}";
                }
                else
                {
                    selectedInfo = $"Node: {selectedNode.ID}";
                }
            }
            else if (args.Element is Connector selectedConnector)
            {
                selectedInfo = $"Connector: {selectedConnector.ID}\nFrom: {selectedConnector.SourceID}\nTo: {selectedConnector.TargetID}";
            }
        }
        else
        {
            selectedInfo = "Click a node or connector to view details";
        }
        
        StateHasChanged();
    }

    private void OnScrollChanged(ScrollChangedEventArgs args) 
    {
        // Update current values when user pans/zooms via mouse
        if (DiagramRef?.ScrollSettings != null)
        {
            currentZoom = DiagramRef.ScrollSettings.CurrentZoom;
            horizontalOffset = DiagramRef.ScrollSettings.HorizontalOffset;
            verticalOffset = DiagramRef.ScrollSettings.VerticalOffset;
            StateHasChanged();
        }
    }

    #endregion

    #region Zoom and Pan Controls

    private async Task ZoomIn()
    {
        if (DiagramRef != null)
        {
            var newZoom = Math.Min(currentZoom + 0.25, 5.0);
            DiagramRef.Zoom(newZoom / currentZoom, null);
            Logger.LogInformation($"Zoom set to {newZoom}.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ZoomOut()
    {
        if (DiagramRef != null)
        {
            var newZoom = Math.Max(currentZoom - 0.25, 0.2);
            DiagramRef.Zoom(newZoom / currentZoom, null);
            Logger.LogInformation($"Zoom set to {newZoom}.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task FitToPage()
    {
        if (nodes.Count > 0)
        {
            DiagramRef?.FitToPage();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ResetView()
    {
        if (DiagramRef != null)
        {
            DiagramRef.Zoom(1.0 / currentZoom, null);
            // Reset pan to center
            if (DiagramRef.ScrollSettings != null)
            {
                DiagramRef.ScrollSettings.HorizontalOffset = 0;
                DiagramRef.ScrollSettings.VerticalOffset = 0;
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    #endregion
    
    private void DebugDiagramTransformed(int sampleNodes = 5)
    {
        if (DiagramRef == null)
        {
            Logger.LogWarning("DiagramRef is null, cannot print transformed positions.");
            return;
        }

        Logger.LogInformation("Diagram viewport: {Width}x{Height}, Zoom={Zoom}, HOffset={H}, VOffset={V}",
            DiagramRef.Width, DiagramRef.Height, currentZoom, horizontalOffset, verticalOffset);

        var count = Math.Min(sampleNodes, nodes.Count);
        var rnd = new Random();
        var sampledNodes = nodes.OrderBy(_ => rnd.Next()).Take(count).ToList();

        foreach (var node in sampledNodes)
        {
            // Apply zoom & pan to get rendered position
            var renderedX = node.OffsetX * currentZoom + horizontalOffset;
            var renderedY = node.OffsetY * currentZoom + verticalOffset;

            Logger.LogInformation(
                "Node at position: original ({X},{Y}) -> rendered ({RX},{RY}) at zoom {Z}",
                node.OffsetX, node.OffsetY, renderedX, renderedY, currentZoom);
        }
    }

}