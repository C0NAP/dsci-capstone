@page "/Graph"
@rendermode InteractiveServer

@using Syncfusion.Blazor.Diagram
@using Syncfusion.Blazor.Buttons
@using Neo4j.Driver
@using Microsoft.Msagl.Core.Geometry.Curves
@using Microsoft.Msagl.Core.Layout
@using Microsoft.Msagl.Layout.Layered
@using Microsoft.Msagl.Miscellaneous

@inject IDriver Neo4jDriver
@inject ILogger<Graph> Logger

<h3>Neo4j Graph Visualization</h3>

<div style="display:flex; height:80vh;">
    <div style="flex:1; border:1px solid gray;">
        <SfDiagramComponent @ref="DiagramRef" 
                           Height="100%" 
                           Width="100%"
                           Nodes="@nodes" 
                           Connectors="@connectors"
                           Click="@OnClick"
                           ScrollChanged="@OnScrollChanged"
                           InteractionController="@DiagramInteractions.ZoomPan"
                           Created="@OnDiagramCreated">
            
            @* Enable Interactive Pan and Zoom with Mouse Wheel *@
            <ScrollSettings CurrentZoom="1.0" 
                           MinZoom="0.2" 
                           MaxZoom="5.0"
                           HorizontalOffset="0" 
                           VerticalOffset="0"
                           EnableAutoScroll="true"
                           ScrollLimit="ScrollLimitMode.Infinity">
            </ScrollSettings>
            
            @* Enable snap to grid for better node positioning *@
            <SnapSettings Constraints="SnapConstraints.ShowLines">
            </SnapSettings>
            
        </SfDiagramComponent>
    </div>
    
    <div style="width:300px; padding:10px; border-left:1px solid gray;">
        <h4>Layout Controls</h4>
        <div style="margin-bottom:15px;">
            <SfButton Content="Apply MSAGL Layout" CssClass="e-success e-small" OnClick="@ApplyMSAGLLayout" />
            <SfButton Content="Random Layout" CssClass="e-warning e-small" OnClick="@ApplyRandomLayout" />
        </div>
        
        <h4>Zoom & Pan Controls</h4>
        <div style="margin-bottom:15px;">
            <SfButton Content="Zoom In" CssClass="e-primary e-small" OnClick="@ZoomIn" />
            <SfButton Content="Zoom Out" CssClass="e-primary e-small" OnClick="@ZoomOut" />
            <SfButton Content="Fit to Page" CssClass="e-success e-small" OnClick="@FitToPage" />
            <SfButton Content="Reset" CssClass="e-danger e-small" OnClick="@ResetView" />
        </div>
        
        <h4>Current Status</h4>
        <div style="margin-bottom:15px;">
            <p><strong>Zoom:</strong> @currentZoom.ToString("F2")x</p>
            <p><strong>Pan X:</strong> @horizontalOffset.ToString("F0")px</p>
            <p><strong>Pan Y:</strong> @verticalOffset.ToString("F0")px</p>
            <p><strong>Layout:</strong> @currentLayoutType</p>
        </div>
        
        <h4>Selected Item</h4>
        <pre style="background:#f5f5f5; padding:10px; border-radius:4px;">@selectedInfo</pre>

        <h4>Debug Info</h4>
        <p><strong>Nodes:</strong> @nodes.Count</p>
        <p><strong>Connectors:</strong> @connectors.Count</p>

        <details>
            <summary>Node Details</summary>
            <div style="max-height:200px; overflow-y:auto;">
                @foreach (var node in nodes)
                {
                    <p style="font-size:12px; margin:2px 0;">
                        @node.ID - (@node.OffsetX.ToString("F0"), @node.OffsetY.ToString("F0"))
                    </p>
                }
            </div>
        </details>
    </div>
</div>

@code {
    private SfDiagramComponent? DiagramRef;
    private readonly DiagramObjectCollection<Syncfusion.Blazor.Diagram.Node> nodes = [];
    private readonly DiagramObjectCollection<Connector> connectors = [];
    
    private string selectedInfo = "Click a node or connector to view details";
    private double currentZoom = 1.0;
    private double horizontalOffset = 0;
    private double verticalOffset = 0;
    private string currentLayoutType = "Random";

    private readonly Dictionary<string, (string label, List<string> properties)> nodeData = [];

    
    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("Loading initial graph...");
        await LoadGraphFromNeo4j();

        // Force UI update so Diagram can render nodes
        StateHasChanged();
    }

    private async Task OnDiagramCreated()
    {
        Logger.LogInformation("Diagram created; safe to add nodes/connectors and call FitToPage.");

        if (nodes.Count > 0)
        {
            // Apply MSAGL layout immediately after diagram creation
            await ApplyMSAGLLayout();
            DiagramRef?.FitToPage();
            await InvokeAsync(StateHasChanged);
        }
        else
        {
            Logger.LogWarning("No nodes loaded to display in Diagram.");
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogInformation(
                "First render complete. Nodes: {NodeCount}, Connectors: {ConnectorCount}", 
                nodes.Count, connectors.Count);

            if (nodes.Count > 0)
            {
                Logger.LogInformation("Nodes loaded; waiting for Diagram Created event to apply MSAGL layout.");
            }
            else
            {
                Logger.LogWarning("No nodes loaded from Neo4j!");
            }
        }

        return Task.CompletedTask;
    }

    private async Task LoadGraphFromNeo4j()
    {
        var session = Neo4jDriver.AsyncSession();
        var processedNodes = new HashSet<string>();
        var processedRelationships = new HashSet<string>();
        var connectionTracker = new Dictionary<string, List<(string relType, string relId, bool isReverse)>>();

        try
        {
            Logger.LogInformation("Running Cypher query...");
            var result = await session.RunAsync(@"
                MATCH (n)-[r]->(m)
                RETURN n, r, m
                LIMIT 50
            ");
            var records = await result.ToListAsync();
            Logger.LogInformation("Fetched {Count} results.", records.Count);
            
            foreach (var record in records)
            {
                var n1Node = record["n"].As<INode>();
                var n2Node = record["m"].As<INode>();
                var rel = record["r"].As<IRelationship>();

                // Process source node
                if (!processedNodes.Contains(n1Node.ElementId))
                {
                    var node1 = CreateNodeFromNeo4j(n1Node);
                    nodes.Add(node1);
                    processedNodes.Add(n1Node.ElementId);
                }

                // Process target node
                if (!processedNodes.Contains(n2Node.ElementId))
                {
                    var node2 = CreateNodeFromNeo4j(n2Node);
                    nodes.Add(node2);
                    processedNodes.Add(n2Node.ElementId);
                }

                // Track bidirectional connections for better routing
                var connectionKey = GetConnectionKey(n1Node.ElementId, n2Node.ElementId);
                if (!connectionTracker.ContainsKey(connectionKey))
                    connectionTracker[connectionKey] = new List<(string, string, bool)>();
                
                connectionTracker[connectionKey].Add((rel.Type, rel.ElementId, false));

                // Process relationship
                var relationshipKey = $"{n1Node.ElementId}-{rel.Type}-{n2Node.ElementId}";
                if (!processedRelationships.Contains(relationshipKey))
                {
                    processedRelationships.Add(relationshipKey);
                }
            }

            // Create connectors with bidirectional awareness
            foreach (var (connectionKey, relationships) in connectionTracker)
            {
                var parts = connectionKey.Split('|');
                var nodeId1 = parts[0];
                var nodeId2 = parts[1];
                
                for (int i = 0; i < relationships.Count; i++)
                {
                    var (relType, relId, _) = relationships[i];
                    var connector = CreateConnectorFromNeo4j(nodeId1, nodeId2, relType, relId, i, relationships.Count);
                    connectors.Add(connector);
                }
            }
            
            Logger.LogInformation("Created {NodeCount} nodes and {ConnectorCount} relations.", nodes.Count, connectors.Count);
        }
        finally
        {
            await session.CloseAsync();
        }
    }
    
    private string GetNodeLabel(INode neoNode, int maxLength = 20)
    {
        // Get name property or fallback to first label
        var label = neoNode.Properties.TryGetValue("name", out var property) 
            ? property?.ToString() : neoNode.Labels.FirstOrDefault();

        // Fallback if null or whitespace
        label = string.IsNullOrWhiteSpace(label) ? "<MISSING NAME>" : label.Trim();

        // Truncate if too long
        if (label.Length > maxLength)
            label = label[..(maxLength - 3)] + "...";

        return label;
    }

    private Syncfusion.Blazor.Diagram.Node CreateNodeFromNeo4j(INode neoNode)
    {
        // Use the "name" property as the label if it exists
        var label = GetNodeLabel(neoNode);
    
        var properties = neoNode.Properties
            .Select(kvp => $"{kvp.Key}: {kvp.Value}")
            .ToList();
    
        nodeData[neoNode.ElementId] = (label, properties);
    
        return new Syncfusion.Blazor.Diagram.Node()
        {
            ID = neoNode.ElementId,
            OffsetX = GetRandomPosition(100, 800),
            OffsetY = GetRandomPosition(100, 600),
            Width = 140,
            Height = 40,
            Shape = new BasicShape() 
            { 
                Type = NodeShapes.Basic, 
                Shape = NodeBasicShapes.Rectangle,
                CornerRadius = 20
            },
            Style = new ShapeStyle() 
            { 
                Fill = GetNodeColor(label),
                StrokeColor = "#333333",
                StrokeWidth = 2
            },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>()
            {
                new ShapeAnnotation 
                { 
                    Content = label,
                    Style = new TextStyle() 
                    { 
                        Color = "black", 
                        Bold = true,
                        FontSize = 12
                    }
                }
            }
        };
    }
    
    private Connector CreateConnectorFromNeo4j(string sourceId, string targetId, string relationshipType, string relationshipId, int connectionIndex, int totalConnections)
    {
        // Calculate offset for multiple connections between same nodes
        var baseOffset = 0.0;
        if (totalConnections > 1)
        {
            // Distribute connections with different curvatures
            var offsetRange = 60.0; // Maximum offset in pixels
            baseOffset = (connectionIndex - (totalConnections - 1) / 2.0) * (offsetRange / Math.Max(totalConnections - 1, 1));
        }

        var connector = new Connector()
        {
            ID = $"conn_{sourceId}_{targetId}_{relationshipType}_{connectionIndex}",
            SourceID = sourceId,
            TargetID = targetId,
            Type = ConnectorSegmentType.Bezier,
            Style = new ShapeStyle()
            {
                StrokeColor = GetConnectorColor(connectionIndex),
                StrokeWidth = 2
            },
            TargetDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.Arrow,
                Style = new ShapeStyle() { Fill = GetConnectorColor(connectionIndex), StrokeColor = GetConnectorColor(connectionIndex) }
            },
            Annotations = new DiagramObjectCollection<PathAnnotation>()
            {
                new PathAnnotation() 
                { 
                    Content = relationshipType,
                    Style = new TextStyle() 
                    { 
                        Color = "#333333",
                        FontSize = 10,
                        Bold = true
                    },
                    // Offset annotation position for multiple connections
                    Offset = totalConnections > 1 ? 0.5 + (connectionIndex * 0.1) : 0.5,
                    Alignment = AnnotationAlignment.Center
                }
            }
        };

        // Apply bezier control point offset for curved routing
        if (Math.Abs(baseOffset) > 1)
        {
            connector.Segments = new DiagramObjectCollection<ConnectorSegment>
            {
                new BezierSegment()
                {
                    Type = ConnectorSegmentType.Bezier,
                    // These control points create the curve offset
                    Point1 = new DiagramPoint() { X = baseOffset, Y = -Math.Abs(baseOffset) },
                    Point2 = new DiagramPoint() { X = -baseOffset, Y = -Math.Abs(baseOffset) }
                }
            };
        }

        return connector;
    }

    private string GetConnectorColor(int index)
    {
        var colors = new[] { "#6495ED", "#FF6B6B", "#4ECDC4", "#96CEB4", "#FFEAA7", "#DDA0DD" };
        return colors[index % colors.Length];
    }

    private string GetConnectionKey(string nodeId1, string nodeId2)
    {
        // Create consistent key regardless of direction for bidirectional tracking
        return string.Compare(nodeId1, nodeId2, StringComparison.Ordinal) < 0 
            ? $"{nodeId1}|{nodeId2}" 
            : $"{nodeId2}|{nodeId1}";
    }

    private string GetNodeColor(string label)
    {
        // Generate colors based on node labels
        var colors = new[] { "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8" };
        var hash = label.GetHashCode();
        return colors[Math.Abs(hash) % colors.Length];
    }

    private static readonly Random _random = new();
    
    private double GetRandomPosition(int min, int max)
    {
        return _random.Next(min, max);
    }

    #region MSAGL Layout Integration

    private async Task ApplyMSAGLLayout()
    {
        if (nodes.Count == 0)
        {
            Logger.LogWarning("No nodes to layout with MSAGL.");
            return;
        }

        try
        {
            Logger.LogInformation("Applying MSAGL layout to {NodeCount} nodes...", nodes.Count);
            
            // Create MSAGL geometry graph
            var geometryGraph = new Microsoft.Msagl.Core.Layout.GeometryGraph();
            var nodeMap = new Dictionary<string, Microsoft.Msagl.Core.Layout.Node>();

            // Add nodes to MSAGL graph
            foreach (var syncNode in nodes)
            {
                var msaglNode = new Microsoft.Msagl.Core.Layout.Node(
                    CurveFactory.CreateRectangle((double)syncNode.Width, (double)syncNode.Height, new Microsoft.Msagl.Core.Geometry.Point()),
                    syncNode.ID);
                
                geometryGraph.Nodes.Add(msaglNode);
                nodeMap[syncNode.ID] = msaglNode;
            }

            // Add edges to MSAGL graph
            foreach (var connector in connectors)
            {
                if (nodeMap.TryGetValue(connector.SourceID, out var sourceNode) && 
                    nodeMap.TryGetValue(connector.TargetID, out var targetNode))
                {
                    var edge = new Microsoft.Msagl.Core.Layout.Edge(sourceNode, targetNode);
                    geometryGraph.Edges.Add(edge);
                }
            }

            // Configure and run MSAGL layout
            var layoutSettings = new SugiyamaLayoutSettings
            {
                Transformation = PlaneTransformation.Rotation(Math.PI / 2), // Rotate for better fit
                NodeSeparation = 80,  // Increase separation to reduce overlap
                LayerSeparation = 100, // Vertical separation between layers
                MinNodeWidth = 140,
                MinNodeHeight = 40
            };

            var layoutEngine = new LayeredLayout(geometryGraph, layoutSettings);
            layoutEngine.Run();

            // Apply calculated positions back to Syncfusion nodes
            foreach (var syncNode in nodes)
            {
                if (nodeMap.TryGetValue(syncNode.ID, out var msaglNode))
                {
                    syncNode.OffsetX = msaglNode.Center.X;
                    syncNode.OffsetY = msaglNode.Center.Y;
                }
            }

            currentLayoutType = "MSAGL Layered";
            Logger.LogInformation("MSAGL layout applied successfully.");
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error applying MSAGL layout: {Message}", ex.Message);
            currentLayoutType = "MSAGL Failed";
        }
    }

    private async Task ApplyRandomLayout()
    {
        Logger.LogInformation("Applying random layout...");
        
        foreach (var node in nodes)
        {
            node.OffsetX = GetRandomPosition(100, 1200);
            node.OffsetY = GetRandomPosition(100, 800);
        }
        
        currentLayoutType = "Random";
        await InvokeAsync(StateHasChanged);
    }

    #endregion

    #region Event Handlers

    private void OnClick(ClickEventArgs args)
    {
        if (args.Element != null)
        {
            if (args.Element is Syncfusion.Blazor.Diagram.Node selectedNode)
            {
                if (selectedNode.ID != null && nodeData.TryGetValue(selectedNode.ID, out var data))
                {
                    selectedInfo = $"Node: {data.label}\nID: {selectedNode.ID}\nProperties:\n{string.Join("\n", data.properties)}";
                }
                else
                {
                    selectedInfo = $"Node: {selectedNode.ID}";
                }
            }
            else if (args.Element is Connector selectedConnector)
            {
                selectedInfo = $"Connector: {selectedConnector.ID}\nFrom: {selectedConnector.SourceID}\nTo: {selectedConnector.TargetID}";
            }
        }
        else
        {
            selectedInfo = "Click a node or connector to view details";
        }
        
        StateHasChanged();
    }

    private void OnScrollChanged(ScrollChangedEventArgs args) 
    {
        // Update current values when user pans/zooms via mouse
        if (DiagramRef?.ScrollSettings != null)
        {
            currentZoom = DiagramRef.ScrollSettings.CurrentZoom;
            horizontalOffset = DiagramRef.ScrollSettings.HorizontalOffset;
            verticalOffset = DiagramRef.ScrollSettings.VerticalOffset;
            StateHasChanged();
        }
    }

    #endregion

    #region Zoom and Pan Controls

    private async Task ZoomIn()
    {
        if (DiagramRef != null)
        {
            var newZoom = Math.Min(currentZoom + 0.25, 5.0);
            DiagramRef.Zoom(newZoom / currentZoom, null);
            Logger.LogInformation($"Zoom set to {newZoom}.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ZoomOut()
    {
        if (DiagramRef != null)
        {
            var newZoom = Math.Max(currentZoom - 0.25, 0.2);
            DiagramRef.Zoom(newZoom / currentZoom, null);
            Logger.LogInformation($"Zoom set to {newZoom}.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task FitToPage()
    {
        if (nodes.Count > 0)
        {
            DiagramRef?.FitToPage();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ResetView()
    {
        if (DiagramRef != null)
        {
            DiagramRef.Zoom(1.0 / currentZoom, null);
            // Reset pan to center
            if (DiagramRef.ScrollSettings != null)
            {
                DiagramRef.ScrollSettings.HorizontalOffset = 0;
                DiagramRef.ScrollSettings.VerticalOffset = 0;
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    #endregion
    
    private void DebugDiagramTransformed(int sampleNodes = 5)
    {
        if (DiagramRef == null)
        {
            Logger.LogWarning("DiagramRef is null, cannot print transformed positions.");
            return;
        }

        Logger.LogInformation("Diagram viewport: {Width}x{Height}, Zoom={Zoom}, HOffset={H}, VOffset={V}",
            DiagramRef.Width, DiagramRef.Height, currentZoom, horizontalOffset, verticalOffset);

        var count = Math.Min(sampleNodes, nodes.Count);
        var rnd = new Random();
        var sampledNodes = nodes.OrderBy(_ => rnd.Next()).Take(count).ToList();

        foreach (var node in sampledNodes)
        {
            // Apply zoom & pan to get rendered position
            var renderedX = node.OffsetX * currentZoom + horizontalOffset;
            var renderedY = node.OffsetY * currentZoom + verticalOffset;

            Logger.LogInformation(
                "Node at position: original ({X},{Y}) -> rendered ({RX},{RY}) at zoom {Z}",
                node.OffsetX, node.OffsetY, renderedX, renderedY, currentZoom);
        }
    }

}